/**
 * The `FromEither` type class represents those data types which support errors.
 *
 * @since 2.10.0
 */
import * as E from './Either';
import { flow } from './function';
export function fromOption(F) {
    return function (onNone) { return flow(E.fromOption(onNone), F.fromEither); };
}
export function fromPredicate(F) {
    return function (predicate, onFalse) {
        return flow(E.fromPredicate(predicate, onFalse), F.fromEither);
    };
}
export function fromOptionK(F) {
    var fromOptionF = fromOption(F);
    return function (onNone) {
        var from = fromOptionF(onNone);
        return function (f) { return flow(f, from); };
    };
}
export function chainOptionK(F, M) {
    var fromOptionKF = fromOptionK(F);
    return function (onNone) {
        var from = fromOptionKF(onNone);
        return function (f) { return function (ma) { return M.chain(ma, from(f)); }; };
    };
}
export function fromEitherK(F) {
    return function (f) { return flow(f, F.fromEither); };
}
export function chainEitherK(F, M) {
    var fromEitherKF = fromEitherK(F);
    return function (f) { return function (ma) { return M.chain(ma, fromEitherKF(f)); }; };
}
export function filterOrElse(F, M) {
    return function (predicate, onFalse) { return function (ma) {
        return M.chain(ma, flow(E.fromPredicate(predicate, onFalse), F.fromEither));
    }; };
}
